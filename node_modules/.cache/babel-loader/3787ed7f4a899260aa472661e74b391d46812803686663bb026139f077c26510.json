{"ast":null,"code":"/**\n * Finds the next empty cell (represented by 0) on the board.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board.\n * @returns {Array<number>|null} - [row, col] of the empty cell, or null if no empty cells.\n */\nexport function findEmpty(board) {\n  for (let r = 0; r < 9; r++) {\n    for (let c = 0; c < 9; c++) {\n      if (board[r][c] === 0) {\n        return [r, c];\n      }\n    }\n  }\n  return null; // No empty cells found\n}\n\n/**\n * Checks if placing a number at a specific position is valid according to Sudoku rules.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board.\n * @param {number} num - The number to check (1-9).\n * @param {number} row - The row index.\n * @param {number} col - The column index.\n * @returns {boolean} - True if valid, false otherwise.\n */\nexport function isValid(board, num, row, col) {\n  // Check row\n  for (let x = 0; x < 9; x++) {\n    if (board[row][x] === num && x !== col) {\n      return false;\n    }\n  }\n\n  // Check column\n  for (let x = 0; x < 9; x++) {\n    if (board[x][col] === num && x !== row) {\n      return false;\n    }\n  }\n\n  // Check 3x3 box\n  const startRow = Math.floor(row / 3) * 3;\n  const startCol = Math.floor(col / 3) * 3;\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      if (board[startRow + i][startCol + j] === num && (startRow + i !== row || startCol + j !== col)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Solves the Sudoku board using a backtracking algorithm.\n * This function modifies the board in place.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board to solve.\n * @returns {boolean} - True if a solution is found, false otherwise.\n */\nexport function solveSudoku(board) {\n  const find = findEmpty(board);\n  if (!find) {\n    return true; // No empty cells, puzzle solved\n  }\n  const [row, col] = find;\n  for (let num = 1; num <= 9; num++) {\n    if (isValid(board, num, row, col)) {\n      board[row][col] = num;\n      if (solveSudoku(board)) {\n        return true; // Solution found\n      }\n      board[row][col] = 0; // Backtrack\n    }\n  }\n  return false; // No solution found for this path\n}\n\n/**\n * Checks if the current board state is a valid and complete Sudoku solution.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board.\n * @returns {boolean} - True if the board is completely and correctly filled, false otherwise.\n */\nexport function checkCurrentBoard(board) {\n  for (let r = 0; r < 9; r++) {\n    for (let c = 0; c < 9; c++) {\n      const num = board[r][c];\n      if (num === 0 || !isValid(board, num, r, c)) {\n        return false; // Cell is empty or invalid\n      }\n    }\n  }\n  return true; // All cells are filled and valid\n}\n\n/**\n * Generates a new solvable Sudoku puzzle.\n * This is a simplified generation that fills a board and then removes cells.\n * It might not guarantee a unique solution, but it will be solvable.\n * @returns {Array<Array<number>>} - A new Sudoku puzzle.\n */\nexport function generateNewPuzzle() {\n  let newBoard = Array(9).fill(0).map(() => Array(9).fill(0));\n\n  // Fill the board completely using the solver\n  // This ensures a valid starting point\n  solveSudoku(newBoard);\n\n  // Create a deep copy to remove cells from\n  let puzzle = JSON.parse(JSON.stringify(newBoard));\n\n  // Randomly remove cells to create the puzzle\n  let cellsToRemove = 50; // Adjust difficulty here (more cells removed = harder)\n  while (cellsToRemove > 0) {\n    const r = Math.floor(Math.random() * 9);\n    const c = Math.floor(Math.random() * 9);\n    if (puzzle[r][c] !== 0) {\n      puzzle[r][c] = 0;\n      cellsToRemove--;\n    }\n  }\n  return puzzle;\n}","map":{"version":3,"names":["findEmpty","board","r","c","isValid","num","row","col","x","startRow","Math","floor","startCol","i","j","solveSudoku","find","checkCurrentBoard","generateNewPuzzle","newBoard","Array","fill","map","puzzle","JSON","parse","stringify","cellsToRemove","random"],"sources":["/Users/ronitjain/Sudoku-solver-with-Ai/src/utils/sudokuUtils.js"],"sourcesContent":["/**\n * Finds the next empty cell (represented by 0) on the board.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board.\n * @returns {Array<number>|null} - [row, col] of the empty cell, or null if no empty cells.\n */\nexport function findEmpty(board) {\n  for (let r = 0; r < 9; r++) {\n    for (let c = 0; c < 9; c++) {\n      if (board[r][c] === 0) {\n        return [r, c];\n      }\n    }\n  }\n  return null; // No empty cells found\n}\n\n/**\n * Checks if placing a number at a specific position is valid according to Sudoku rules.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board.\n * @param {number} num - The number to check (1-9).\n * @param {number} row - The row index.\n * @param {number} col - The column index.\n * @returns {boolean} - True if valid, false otherwise.\n */\nexport function isValid(board, num, row, col) {\n  // Check row\n  for (let x = 0; x < 9; x++) {\n    if (board[row][x] === num && x !== col) {\n      return false;\n    }\n  }\n\n  // Check column\n  for (let x = 0; x < 9; x++) {\n    if (board[x][col] === num && x !== row) {\n      return false;\n    }\n  }\n\n  // Check 3x3 box\n  const startRow = Math.floor(row / 3) * 3;\n  const startCol = Math.floor(col / 3) * 3;\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      if (board[startRow + i][startCol + j] === num && (startRow + i !== row || startCol + j !== col)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Solves the Sudoku board using a backtracking algorithm.\n * This function modifies the board in place.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board to solve.\n * @returns {boolean} - True if a solution is found, false otherwise.\n */\nexport function solveSudoku(board) {\n  const find = findEmpty(board);\n  if (!find) {\n    return true; // No empty cells, puzzle solved\n  }\n\n  const [row, col] = find;\n\n  for (let num = 1; num <= 9; num++) {\n    if (isValid(board, num, row, col)) {\n      board[row][col] = num;\n\n      if (solveSudoku(board)) {\n        return true; // Solution found\n      }\n\n      board[row][col] = 0; // Backtrack\n    }\n  }\n  return false; // No solution found for this path\n}\n\n/**\n * Checks if the current board state is a valid and complete Sudoku solution.\n * @param {Array<Array<number>>} board - The 9x9 Sudoku board.\n * @returns {boolean} - True if the board is completely and correctly filled, false otherwise.\n */\nexport function checkCurrentBoard(board) {\n  for (let r = 0; r < 9; r++) {\n    for (let c = 0; c < 9; c++) {\n      const num = board[r][c];\n      if (num === 0 || !isValid(board, num, r, c)) {\n        return false; // Cell is empty or invalid\n      }\n    }\n  }\n  return true; // All cells are filled and valid\n}\n\n/**\n * Generates a new solvable Sudoku puzzle.\n * This is a simplified generation that fills a board and then removes cells.\n * It might not guarantee a unique solution, but it will be solvable.\n * @returns {Array<Array<number>>} - A new Sudoku puzzle.\n */\nexport function generateNewPuzzle() {\n  let newBoard = Array(9).fill(0).map(() => Array(9).fill(0));\n\n  // Fill the board completely using the solver\n  // This ensures a valid starting point\n  solveSudoku(newBoard);\n\n  // Create a deep copy to remove cells from\n  let puzzle = JSON.parse(JSON.stringify(newBoard));\n\n  // Randomly remove cells to create the puzzle\n  let cellsToRemove = 50; // Adjust difficulty here (more cells removed = harder)\n  while (cellsToRemove > 0) {\n    const r = Math.floor(Math.random() * 9);\n    const c = Math.floor(Math.random() * 9);\n    if (puzzle[r][c] !== 0) {\n      puzzle[r][c] = 0;\n      cellsToRemove--;\n    }\n  }\n  return puzzle;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}